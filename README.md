<a name="begining"><h1>О проекте</h1></a>

- [О проекте](#begining)
	- [Запуск](#8)
  - [Описание](#2)
    - [Технологии](#3)
	- [Структура проекта](#4)
	- [Взаимодействие с БД](#5)
  - [Скрипты](#6)
  	- [Конфигурация Jest](#7)
  - [Тестирование](#9)
  	- [Unit-тестирование](#10)
	- [Интеграционное тестирование](#11)

<a name="8"><h2>Запуск</h2></a>

> [!CAUTION]
> **Запуск:** Для реализации безопасности строки подключения к БД пароль для входа НЕ хранится в config-файле - нужно вводить его вручную.
> Таким образом, запуск программы осуществляется:
> 1) `npm start`
> 2) Введите пароль нужного вам пользователя, который знаете только Вы и я! (Мой начинается на **62I8...**, заканчивается на **...u4Lh**).



<a name="2"><h2>Описание</h2></a>

Данный проект работает со списком всех персонажей из сервиса https://rickandmortyapi.com/
Конкретно по шагам:

1. Удаляется таблица <table-name> в базе данных PostgreSQL.
2. Запускается скрипт в Replit (https://replit.com/).
3. В базе должна создаться таблица <table-name>
4. В таблицу <table-name> должны быть загружены данные в соответствии с
требованиями к структуре таблицы из API https://rickandmortyapi.com/

<a name="3"><h3>Технологии</h3></a>
- Node.js
- Typescript
- Jest
- PostgreSQL
- JSDoc

> [!TIP]
> Для проекта был выбран Typescript для лучше типизации (см. модели - character.ts, Jest - для тестирования, а JSDoc - как вид документации).

<a name="4"><h3>Структура проекта</h3></a>

```
Nodejs-Rick-And-Morty-Api/
│
├── src/
│   ├── config/
│   │   └── database.ts        // Конфигурация подключения к базе данных
│   ├── models/
│   │   └── character.ts     // Файл с интерфейсом Character
│   │
│   ├── services/
│   │   ├── characterService.ts     // Сервис для работы с данными персонажей из API
│   │   └── databaseService.ts      // Сервис для работы с базой данных
│   │
│   └── tests/
│   │   ├── integration/
│   │   │   └── databaseService.test.ts  // Интеграционные тесты для сервиса базы данных
│   │   └── unit/
│   │       └── characterService.test.ts   // Юнит-тесты для сервиса персонажей
│   │
│   └── utils/
│       └── errorHandler.ts    // Утилита для обработки ошибок
│
├── jest.config.js             // Конфигурация Jest для тестов
├── package.json               // Файл с зависимостями и скриптами
├── tsconfig.json              // Конфигурация TypeScript
└── README.md                  // Описание проекта и инструкции
```
> [!IMPORTANT]
> Точкой входа является файл index.ts, это можно увидеть в package.json: "start": "ts-node src/index.ts",

<a name="5"><h3>Взаимодействие с БД</h3></a>

Данная программа реализует следующий скрипт внутри БД
```SQL
-- Удаление таблицы, если она существует
DROP TABLE IF EXISTS table_name;

-- Создание новой таблицы
CREATE TABLE table_name (
    Id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    data JSONB NOT NULL
);

-- А также вставка данных из API построчно на примере записи:

INSERT INTO your_github_nickname (name, data) 
VALUES 
('Toxic Rick', '{
    "id": 127,
    "name": "Frank Palicky",
    "status": "Dead",
    "species": "Human",
    "type": "",
    "gender": "Male",
    "origin": {
        "name": "Earth (C-137)",
        "url": "https://rickandmortyapi.com/api/location/1"
    },
    "location": {
        "name": "Earth (C-137)",
        "url": "https://rickandmortyapi.com/api/location/1"
    },
    "image": "https://rickandmortyapi.com/api/character/avatar/127.jpeg",
    "episode": [
        "https://rickandmortyapi.com/api/episode/1"
    ],
    "url": "https://rickandmortyapi.com/api/character/127",
    "created": "2017-12-26T19:22:48.474Z"
}');
```

<a name="6"><h2>Скрипты</h2></a>

- **start:** Запускает приложение в режиме разработки с помощью `ts-node`, что позволяет использовать TypeScript без необходимости предварительной компиляции в JavaScript.
- **build:** Компилирует весь TypeScript код в JavaScript, помещая результаты в папку `dist`.
- **test:** Запускает тесты с использованием Jest. В данном случае используется опция `--config jest.config.js` для указания конфигурационного файла Jest.

- Для запуска приложения сначала установите зависимости:
  ```
  npm install
  ```
- Для запуска приложения в режиме разработки:
  ```
  npm start
  ```

- Для компиляции TypeScript кода:
  ```
  npm run build
  ```

- Для запуска тестов:
  ```
  npm test
  ```

<a name="7"><h3>Конфигурация Jest</h3></a>

Мы имеем конфигурацию Jest в файле `jest.config.js`, поэтому в скрипте `"test"` указывается этот файл для настройки тестового окружения Jest.

```json
{
   ...,
  "scripts": {
    "start": "ts-node src/index.ts",      // Запуск приложения в режиме разработки
    "build": "tsc",                       // Сборка TypeScript кода
    "test": "jest --config jest.config.js" // Запуск тестов с использованием Jest и его конфигурации
  }, ...
}
```

<a name="9"><h2>Тестирование</h2></a>

<a name="10"><h3>Unit-тестирование</h3></a>

Тест для `fetchCharacters` из `characterService` можно классифицировать как **юнит-тест**:

Юнит-тест направлен на тестирование отдельных частей кода, таких как функции или методы, независимо от их внешних зависимостей. Наш тест на `fetchCharacters` отвечает следующим критериям для юнит-тестирования:

1. **Изоляция функции**: Мы тестируем только функцию `fetchCharacters` из модуля `characterService`. Это означает, что наши тесты не зависят от других частей системы, таких как база данных или внешние API.

2. **Мокирование внешних зависимостей не требуется**: В нашем тесте нет необходимости использовать моки или заглушки для внешних зависимостей, так как функция `fetchCharacters` сама по себе изолирована и не требует взаимодействия с внешними сервисами.

3. **Целевая проверка**: В тесте проверяется ожидаемое поведение функции `fetchCharacters` - возвращение массива персонажей с определенными свойствами (`id, name, status`). Это помогает убедиться, что функция возвращает корректные данные в ожидаемом формате.

<a name="11"><h3>Интеграционное тестирование</h3></a>

Тест, который мы написали для `databaseService` является **интеграционным тестом**:

Интеграционный тест проверяет взаимодействие между различными компонентами или модулями системы в ее реальной или симулированной среде. Он охватывает несколько модулей или компонентов, чтобы убедиться, что они работают вместе правильно. В нашем случае:

1. **Использование реального клиента PostgreSQL:** Мы создаём экземпляр `Client` из библиотеки `pg` и используем его в функциях `initDatabase` и `insertCharacters`. Это подразумевает реальное взаимодействие с базой данных (хотя сама база данных не создается и не удаляется в реальной СУБД).

2. **Тестирование выполнения SQL-запросов:** Мы проверяем, что функции `initDatabase` и `insertCharacters` правильно вызывают метод `query` у `mockedClient`, используя заданные SQL-запросы и параметры.

3. **Ожидание взаимодействия с клиентом PostgreSQL:** Мы ожидаем, что клиент PostgreSQL будет соединяться, выполнять запросы и отключаться.
